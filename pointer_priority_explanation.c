#include <stdio.h>

/*
========================================
なぜ *p.stock はエラーになるのか？
========================================
演算子の優先順位の問題です
*/

struct Product {
    char name[50];
    int price;
    int stock;
};

int main() {
    printf("=== 演算子の優先順位の説明 ===\n\n");
    
    struct Product product = {"りんご", 150, 20};
    struct Product *p = &product;
    
    // ========================================
    // 1. 演算子の優先順位
    // ========================================
    printf("--- 1. 演算子の優先順位 ---\n");
    printf("ドット演算子(.)の優先順位: 高い\n");
    printf("デリファレンス(*)の優先順位: 低い\n");
    printf("\n");
    printf("つまり:\n");
    printf("*p.stock は *(p.stock) と解釈される\n");
    printf("(*p).stock とは違う意味になる！\n\n");
    
    // ========================================
    // 2. *p.stock が何を意味するか
    // ========================================
    printf("--- 2. *p.stock の意味 ---\n");
    printf("コンパイラの解釈:\n");
    printf("1. まず p.stock を評価しようとする\n");
    printf("2. でも p はポインタなので .stock は使えない\n");
    printf("3. エラー！\n\n");
    
    // ========================================
    // 3. 正しい書き方
    // ========================================
    printf("--- 3. 正しい書き方 ---\n");
    printf("(*p).stock の意味:\n");
    printf("1. まず (*p) を評価 → 構造体の実体を取得\n");
    printf("2. 次に .stock を評価 → メンバにアクセス\n");
    printf("3. 成功！\n\n");
    
    // 実際に使ってみる
    printf("商品名: %s\n", (*p).name);
    printf("価格: %d円\n", (*p).price);
    printf("在庫: %d個\n\n", (*p).stock);
    
    // ========================================
    // 4. 図で理解する
    // ========================================
    printf("--- 4. 図で理解する ---\n\n");
    
    printf("【間違い】 *p.stock\n");
    printf("         ↓\n");
    printf("    *(p.stock)\n");
    printf("      ↑\n");
    printf("    pはポインタなので\n");
    printf("    .stockは使えない → エラー！\n\n");
    
    printf("【正しい】 (*p).stock\n");
    printf("         ↓\n");
    printf("    (*p)  .stock\n");
    printf("     ↑     ↑\n");
    printf("   構造体  メンバ\n");
    printf("   の実体  にアクセス → OK！\n\n");
    
    // ========================================
    // 5. 実例で比較
    // ========================================
    printf("--- 5. 実例で比較 ---\n\n");
    
    printf("正しい書き方:\n");
    printf("在庫を変更前: %d個\n", (*p).stock);
    (*p).stock = 30;  // 正しい
    printf("在庫を変更後: %d個\n\n", (*p).stock);
    
    // 間違った書き方（コメントアウト）
    // *p.stock = 40;  // エラー！コンパイルできない
    
    // ========================================
    // 6. 覚え方
    // ========================================
    printf("--- 6. 覚え方 ---\n\n");
    printf("ポインタ経由で構造体のメンバにアクセス:\n");
    printf("1. まず (*p) で構造体を取り出す\n");
    printf("2. 次に .メンバ名 でアクセス\n");
    printf("3. 括弧を忘れずに！\n\n");
    
    printf("または:\n");
    printf("アロー演算子 p->stock を使う（簡単！）\n");
    printf("p->stock は (*p).stock と同じ意味\n\n");
    
    // ========================================
    // まとめ
    // ========================================
    printf("========================================\n");
    printf("まとめ:\n");
    printf("========================================\n");
    printf("❌ *p.stock     → エラー\n");
    printf("✅ (*p).stock   → 正しい\n");
    printf("✅ p->stock     → 正しい（簡単）\n");
    printf("\n");
    printf("理由: . の優先順位が * より高いから\n");
    printf("解決: 括弧で (*p) を先に評価する\n");
    printf("========================================\n");
    
    return 0;
}

/*
========================================
演算子の優先順位表（高い順）
========================================
1. ()              括弧
2. . ->            メンバアクセス
3. * &             ポインタ、アドレス
4. + -             加算、減算
5. < > <= >=       比較
6. == !=           等価
7. =               代入

だから:
*p.stock は *(p.stock) と解釈される
(*p).stock とするには括弧が必要！

========================================
テストで出る可能性のある問題
========================================

問題1: 次のうち正しいのはどれ？
struct Product *p;

A. *p.stock
B. (*p).stock
C. p->stock

答え: B と C （Aはエラー）

問題2: なぜAはエラーになる？
答え: ドット演算子(.)の優先順位がデリファレンス(*)より
      高いため、p.stockが先に評価されるが、pはポインタ
      なのでドット演算子は使えない。

問題3: (*p).stock と p->stock の違いは？
答え: 意味は同じ。p->stock は (*p).stock の省略形。
*/
