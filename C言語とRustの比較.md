# C言語とRustの比較

## 学習コストと処理速度

### 学習コスト
- **C言語:** シンプルな言語仕様で基本文法は数週間で習得可能。歴史が長く日本語リソースも豊富。
- **Rust:** 所有権・借用・ライフタイムなど独特の概念があり、習得に数ヶ月〜半年。学習曲線が急。

**結論:** C言語の方が学習コストは低い

### 処理速度
- 両方ともネイティブコンパイルで、ベンチマークでは誤差範囲内
- どちらもゼロコスト抽象化を提供
- 並行処理ではRustが安全性の面で有利

**結論:** 処理速度はほぼ同等

---

## C言語の危険な部分（100字要約）

C言語は手動メモリ管理が必要で、バッファオーバーフロー、ダングリングポインタ、二重解放、メモリリーク、NULL参照、データ競合などの危険性がある。これらは実行時エラーやセキュリティ脆弱性の原因となる。

### 詳細な危険性

#### 1. バッファオーバーフロー
```c
char buffer[10];
strcpy(buffer, "これは10文字以上の長い文字列");  // 危険！メモリ破壊
```

#### 2. ダングリングポインタ（解放済みメモリへのアクセス）
```c
int* ptr = malloc(sizeof(int));
free(ptr);
*ptr = 42;  // 危険！解放済みメモリにアクセス
```

#### 3. 二重解放
```c
int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // 危険！同じメモリを2回解放
```

#### 4. メモリリーク
```c
void func() {
    int* ptr = malloc(sizeof(int));
    return;  // freeを忘れた！メモリリーク
}
```

#### 5. NULLポインタ参照
```c
int* ptr = NULL;
*ptr = 10;  // クラッシュ
```

#### 6. データ競合（マルチスレッド）
```c
int counter = 0;
// 複数のスレッドが同時にcounterを変更 → 予測不能な動作
```

---

## Rustの核心概念（100字要約）

Rustは所有権（各値に1つの所有者）、借用（参照の安全な共有）、ライフタイム（参照の有効期間）の3つの概念でメモリ安全性を保証。コンパイル時にチェックし、C言語の危険性を根本的に防ぐ。

### 詳細な核心概念

### 1. 所有権（Ownership）

**ルール:**
- 各値には1つの「所有者」がいる
- 所有者がスコープを抜けると、値は自動的に解放される
- 所有権は移動（move）できる

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // 所有権がs1からs2に移動
    // println!("{}", s1);  // エラー！s1はもう使えない
    println!("{}", s2);  // OK
}  // s2がスコープを抜けると自動的にメモリ解放
```

**Cとの違い:**
- Cでは手動でfree()を呼ぶ必要がある
- Rustは自動的に解放（メモリリークを防ぐ）
- 二重解放も不可能（コンパイルエラーになる）

### 2. 借用（Borrowing）

**ルール:**
- 所有権を移動せずに、参照を渡せる
- 不変借用（&T）は複数同時にOK
- 可変借用（&mut T）は1つだけ、かつ不変借用と同時には不可

```rust
fn main() {
    let mut s = String::from("hello");
    
    // 不変借用（読み取り専用）- 複数OK
    let r1 = &s;
    let r2 = &s;
    println!("{} {}", r1, r2);
    
    // 可変借用（書き込み可能）- 1つだけ
    let r3 = &mut s;
    r3.push_str(" world");
    println!("{}", r3);
}
```

**Cとの違い:**
```c
// Cでは同じポインタを複数の場所で変更できる（危険）
int* ptr1 = &value;
int* ptr2 = &value;
*ptr1 = 10;  // OK
*ptr2 = 20;  // OK（でもptr1経由で見ると予期しない値）
```

Rustはコンパイル時にこれを防ぐ！

### 3. ライフタイム（Lifetime）

**目的:** ダングリングポインタを防ぐ

```rust
fn main() {
    let r;
    {
        let x = 5;
        r = &x;  // エラー！xはこのスコープで消える
    }
    // println!("{}", r);  // xはもう存在しない
}
```

**Cでの同じ問題:**
```c
int* dangling() {
    int x = 5;
    return &x;  // 危険！ローカル変数のアドレスを返す
}
```

Rustはコンパイル時にこれを検出してエラーにする！

---

## Rustがどう安全にしているか

| C言語の問題 | Rustの解決方法 |
|------------|---------------|
| バッファオーバーフロー | 配列アクセス時に境界チェック |
| ダングリングポインタ | ライフタイムで検出 |
| 二重解放 | 所有権システムで不可能 |
| メモリリーク | 自動解放（Drop trait） |
| NULL参照 | Option型で明示的に扱う |
| データ競合 | 借用ルールで防ぐ |

---

## 実例比較

### C（危険）
```c
char* get_name() {
    char name[20] = "Alice";
    return name;  // ダングリングポインタ！
}
```

### Rust（安全）
```rust
fn get_name() -> String {
    let name = String::from("Alice");
    name  // 所有権を返す（安全）
}
```

---

## まとめ

- **C言語:** 学習コストは低いが、メモリ管理を全て手動で行うためミスが起きやすい
- **Rust:** 学習コストは高いが、コンパイラが安全性をチェックし実行時バグが激減
- **推奨学習順序:** Cで基礎を固めてからRustを学ぶと、Rustの設計思想が理解しやすい

Cのポインタやメモリ管理の難しさを経験することで、Rustがなぜそのように設計されたかが腑に落ちる。
